#' Run simulations to determine the steady states by the replication method.
#' 
#' Function to get the steady states for combinations of `a` (oxygen diffusivity) and initial states.
#' This function is multithreaded, and the value of mc.cores determines the umber of parallel threads.
#' @param parameter object of class `ss_by_a_N_parameter` as generated by `new_ss_by_a_N_parameter()`
#' @param mc.cores the number of cores to be used. If 0, the old sequential version is used.
#'   The default is read from the option `mc.cores`, i.e. using `getOption("mc.cores", 0)`.
#' @return Processed data about steady states
#' 
#' @md
#' 
#' @export

ss_by_a_N <- function(
  parameter, 
  mc.cores = getOption("mc.cores", 0)
){
  if (!inherits(parameter, "ss_by_a_N_parameter")) {
    stop("parameter has to be an object of type `ss_by_a_N_parameter`!")
  }
  
  if (Sys.info()['sysname'] == "Window") {
    warning("On windows, mc.cores will always be set to one!")
    mc.cores <- 1
  }
  
  if (mc.cores == 0) {
    temp_result <- apply(
      parameter$ss_expt, 
      1, 
      function(x) {
        get_final_states_a_N(x, parameter)
      }
    )
  } else {
    temp_result <- parallel::mclapply(
      1:nrow(parameter$ss_expt),
      function(i) {
        get_final_states_a_N(parameter$ss_expt[i, ], parameter)
      }, 
      mc.preschedule = FALSE,
      mc.cores = mc.cores
    )
    temp_result <- tibble::as_tibble(
      do.call(rbind, temp_result)
    )
  }

  result <- temp_result %>%
    tibble::tibble() %>%
    tidyr::unnest(cols = 1) %>%
    dplyr::mutate(initial_N_CB = parameter$ss_expt$N_CB,
                  initial_N_PB = parameter$ss_expt$N_PB,
                  initial_N_SB = parameter$ss_expt$N_SB,
                  a_O = parameter$ss_expt$a_O)

   return(new_ss_by_a_N_results(parameter, result))
}