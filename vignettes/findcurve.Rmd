---
title: "FindCurve"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 5
vignette: >
  %\VignetteIndexEntry{FindCurve}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  include = TRUE,
  fig.height = 4,
  fig.width = 8,
  collapse = TRUE,
  comment = "#>"
)
```

# Package Intro
This text is taken from the [FindCurve README](https://bitbucket.org/amderoos/findcurve/src/master/R/)


An R package for computing curves of solutions to non-linear systems of equations

This is a general purpose software package, written in C, that solves non-linear systems of equations of the form

*F*(*x*, *p*) = 0

where *F* is a vector-valued function of a vector *x* of unknowns and *p* represents a parameter. There is little limitation to the formulation of the system of equations, for example, *F*(*x*, *p*) may be defined as the result of an numerical integration of a system of ordinary differential equations (ODEs). For this purpose the package also includes a dedicated numerical solver for ODEs. When a solution point *x* to the system of equations has been found, the package will output all information about the solution point itself and all the values of additional functions *G*(*x*) that the user can define his/herself. Here again, *G*(*x*) is a vector-valued function.

The package is designed to compute curves of points that are solutions to the non-linear equation system as a function of the parameter *p*. In addition, the package has facilities to detect special points in these curves:

- **Branching points (BP):** These points represent special points where 2 different solution curves intersect for a particular parameter value. Although in generic systems of equations this happens only rarely, in systems of equations stemming from biological population dynamics this occurs frequently. These points then represent so-called invasion points, the intersection between a curve representing a zero-valued equilibrium density of a population and a curve representing equilibria with a positive equilibrium density.

- **Limit points (LP):** These points represent special points where a curve reaches a maximum or minimum parameter value and bends back on its self. When the curve represents equilibrium points of a problem in biological population dynamics such a point marks the threshold where a stable equilibrium state and an unstable state (saddle point) merge and disappear.

- **Extreme points (EXT):** These points represent special points where a curve reaches a maximum or minimum in an objective function, which is one of the elements of the vector-valued function *G*(*x*) discussed above. More specifically these points represent values of the parameter *p* where the partial derivative of one of the objective functions with respect to any arbitrary parameter occurring in the system of equations becomes 0. This can be the parameter *p* but also any other parameter.

The package also allows for the computation of the location of these special points (BP, LP, EXT) as a function of two parameters *p* and *q*.

The system of equations to be solved has to be implemented in C, but the package itself can be used from the R command-line, for example, using the Rstudio package. To start implementing a particular system of equations, use one of the example files (with an '.h' extension) provided with the package as a template (use the function `showsystem()` to get a list of all the examples). Unfortunately, at the current moment there is no manual available to describe the use of the package. Look at the examples that can be accessed with the function `demo()` for inspiration how to use it and for a demonstration of its capabilities. Furthermore, consult the help page via `?FindCurve` for the syntax to be used in R.

To install the package on your system use the command:

```
devtools::install_bitbucket("amderoos/FindCurve/R")
```

```{r preparation}
library(microxanoxBeta)
if (!require("FindCurve")) {
  devtools::install_bitbucket("amderoos/FindCurve/R")
  if (!require("FindCurve")){
    stop("Required package 'FindCurve' can not be instelled from https://bitbucket.org/amderoos/findcurve/src/master/R/")
  }
}
```


# Demo CjaP

## The Model

```{c, eval = FALSE}
/***
   NAME
     CjaP
   PURPOSE
     Module computes the internal equilibrium of the stage-structured biomass model
     with a single resource and pulsed reproduction and a single predator

    Last modification: AMdR - Jan 26, 2018
 ***/

/*
 *=====================================================================================================
 *  PROGRAM SETTINGS
 *=====================================================================================================
 */

#define RESFLUC                   0                                     // Set resource dynamics to
 																																				// Semi-chemostat ( = 0) or
 																																				// fluctuating dynamics ( = 1)

/*
 *=====================================================================================================
 *  DEFINITION OF PROBLEM DIMENSIONS AND NUMERICAL SETTINGS
 *=====================================================================================================
 */
// Dimension settings: Required
#define EQUATIONS_DIM             4
#define EXTRAOUTPUT_DIM           6
#define PARAMETER_NR              24

// Numerical settings: Optional (default values adopted otherwise)
#define ODESOLVE_MAX_STEP         0.1                                   // Largest step size in
																																				// odesolver
#define ODESOLVE_REL_ERR          1.0E-10

#define DYTOL                     1.0E-8                                // Variable tolerance
#define RHSTOL                    1.0E-9                                // Function tolerance
#define ALLOWNEGATIVE             0                                     // Negative solution
																																				// components allowed?


/*
 *=====================================================================================================
 *  DEFINITION OF ALIASES
 *=====================================================================================================
 */
// Define aliases for the parameters
#define DELTAR                    parameter[0]
#define RMAX                      parameter[1]

// Parameters for consumer general
#define MC                        parameter[2]
#define TC                        parameter[3]
#define SIGMAC                    parameter[4]
#define ZC                        parameter[5]                          // Body size maturation ratio
#define MUC                       parameter[6]                          // Background mortality
#define QC                        parameter[7]
#define HC                        parameter[8]

#define MUCPLUS                   parameter[9]
#define MUCJPLUS                  parameter[10]
#define MUCAPLUS                  parameter[11]

// Parameters for consumer related to discrete reproduction
#define EPS                       parameter[12]                         // Conversion factor maintenance
																																				// rate gonads
#define INTERVAL                  parameter[13]                         // Duration of period between
																																				// spawning events
#define PSI                       parameter[14]                         // Rep. enrg. all. 2 cont. rep.

// Parameters for predator
#define MP                        parameter[15]
#define TP                        parameter[16]
#define SIGMAP                    parameter[17]
#define MUP                       parameter[18]
#define PHI                       parameter[19]                         // Preference for Juvenile stage
																																				// of consumer
#define HP                        parameter[20]

#define MUPLUSP                   parameter[21]

#define FUNCRESP                  parameter[22]

#define ARESF                     parameter[23]


/*
 *=====================================================================================================
 *  DEFINITION OF NAMES AND DEFAULT VALUES OF THE PARAMETERS
 *=====================================================================================================
 */
// At least two parameters should be specified in this array
char *parameternames[PARAMETER_NR] = {"Delta", "Rmax",     "Mc",  "Tc", "Sigmac", "Zc",
																			"Muc", "Qc",  "Hc", "MucPlus", "MucjPlus", "MucaPlus",
                                      "EPS",   "Interval", "Psi", "Mp", "Tp",     "Sigmap",
                                      "Mup", "Phi", "Hp", "Muplusp", "FuncResp", "AresF"};

// These are the default parameters values
double parameter[PARAMETER_NR] = {0.1, 30.0, 1.0, 0.1,  0.5,   0.1, 0.015, 1.5, 3.0, 0.0, 0.0, 0.0,
                                  0.0, 70.0, 0.0, 0.32, 0.032, 0.5, 0.005, 0.0, 3.0, 0.0, 1.0, 0.0};

/*
 *=====================================================================================================
 *  DEFINITION OF THE SYSTEM OF EQUATIONS TO SOLVE
 *=====================================================================================================
 */

#undef MAX_EXP
#define MAX_EXP                   50.0

double Maturation(double z, double nuj, double muj)

{
  double  logz, tmp, tres, matrate = 0.0;

  logz = log(z);
  tres = muj/(1.0 - MAX_EXP/logz);
  if (nuj < tres)
    matrate = 0.0;
  else
    {
      tmp = 1.0 - muj/nuj;
      if (fabs(tmp) < 1.0E-6)
        matrate = tmp/2 - 1/logz;
      else
        matrate = tmp/(1.0 - exp(tmp*logz));
    }
  matrate *= nuj;

  return matrate;
}


/*====================================================================================================*/

// The ODE system defining the change in state variables during the growth period

#define ODEDIM 11
static double                     StoredVals[ODEDIM];
static int                        OdeDim = ODEDIM;

#define R                         argument[0]                           // Resource
#define CJ                        argument[1]                           // Juvenile consumers
#define CA                        argument[2]                           // Adult consumers
#define P                         argument[3]                           // Predator biomass
#define B                         argument[4]                           // energy storage

#define DRDT                      derivative[0]                         // Resource
#define DCJDT                     derivative[1]                         // Juvenile consumers
#define DCADT                     derivative[2]                         // Adult consumers
#define DPDT                      derivative[3]                         // Predator
#define DBDT                      derivative[4]                         // Energy storage

void WithinSeason(double t, double *argument, double *derivative)
{
  static double ingest_R = 0.0;
  static double nu_J, nu_A;
  static double mort_J, mort_A, maturation, encP;
#if (RESFLUC == 1)
  static double rfluc;
#endif

  ingest_R = MC*((2 - QC)*CJ + QC*CA)*R/((1 - FUNCRESP) + FUNCRESP*(R + HC));
  nu_J     = SIGMAC*(2 - QC)*MC*R/((1 - FUNCRESP) + FUNCRESP*(R + HC)) - TC;
  nu_A     = SIGMAC*QC*MC*R/((1 - FUNCRESP) + FUNCRESP*(R + HC)) - TC*(1 + EPS*B/CA);

  encP = PHI*CJ + (1 - PHI)*(CA + B);

  // mort_J   = MUC - (nu_J - max(nu_J, 0.0));
  // Starvation mortality (max(nu_J, 0.0)-nu_J) included here !
  mort_J = MUC + MUCJPLUS + MUCPLUS + max(-nu_J, 0.0) + MP*PHI*P/((1 - FUNCRESP) + FUNCRESP*(encP + HP));
  mort_A = MUC + MUCAPLUS + MUCPLUS + max(-nu_A, 0.0) + MP*(1 - PHI)*P/((1 - FUNCRESP) + FUNCRESP*(encP + HP));

  maturation = Maturation(ZC, nu_J, mort_J)*CJ;

#if (RESFLUC == 0)
  DRDT = DELTAR*(RMAX - R) - ingest_R;
#elif (RESFLUC == 1)
  rfluc = RMAX*(1 + ARESF*sin(2*M_PI*t/INTERVAL));
  DRDT  = DELTAR*(rfluc - R) - ingest_R;
#endif

  DCJDT = max(nu_J, 0.0)*CJ - maturation - mort_J*CJ + PSI*max(nu_A, 0.0)*CA;
  DCADT = maturation - mort_A*CA;
  DPDT  = (SIGMAP*MP*encP/((1 - FUNCRESP) + FUNCRESP*(encP + HP)) - TP - MUP - MUPLUSP)*P;
  DBDT  = (1 - PSI)*max(nu_A, 0.0)*CA - mort_A*B;

  // Integrate the following ODEs only for output purposes
  if (OdeDim == ODEDIM)
    {
      derivative[5]  = R;
      derivative[6]  = CJ;
      derivative[7]  = CA + B;
      derivative[8]  = CJ + CA + B;
      derivative[9]  = P;
      derivative[10] = (SIGMAP*MP*encP/((1 - FUNCRESP) + FUNCRESP*(encP + HP)) - TP - MUP - MUPLUSP);
    }

  return;
}


/*====================================================================================================*/

// Routine specifying the system of equalities from which to solve for
// R, J and A at equilibrium
#define PERIOD 1

int Equations(double *argument, double *result)

{
  int     period;
  double  tval, tend, x[ODEDIM];

  //================================================================================
  // Set the initial point for the ODEs

  memset(x, 0, ODEDIM*sizeof(double));
  x[0] = R;
  x[1] = CJ;
  x[2] = CA;
  x[3] = P;

  if (result)
    OdeDim = 5;
  else
    OdeDim = ODEDIM;
  tval     = 0.0;
  tend     = INTERVAL;

  for (period = 0; period < PERIOD; period++)
    {
      tend = (period + 1)*INTERVAL;
      // Integrate up to end of the growing phase
      if (odesolve(x, OdeDim, &tval, tend, WithinSeason, NULL) == FAILURE)
        {
          ErrorMsg(__FILE__, __LINE__, "Integration failed!");
          return FAILURE;
        }
      if (!result) memcpy(StoredVals, x, ODEDIM*sizeof(double));
      x[1] += x[4];                                                     // Add reproductive mass
      																																	// to juveniles
      x[4] = 0.0;                                                       // Reset reproductive mass
    }

  //================================================================================
  // Compute the final values of the fixed point equation F(y)=0,

  if (result)
    {
      result[0] = (R - x[0]);
      result[1] = (CJ - x[1]);
      result[2] = (CA - x[2]);
      result[3] = (P - x[3]);
    }

  return SUCCES;
}


/*====================================================================================================*/

// Define all variables to be written to the output file (column-organized ASCII file)

int DefineExtraOutput(double *argument, double *ExtraOutput)

{
  // Invoke the routine that sets the right-hand side for setting the output variables
  if (Equations(argument, NULL) == FAILURE) return FAILURE;

  ExtraOutput[0] = StoredVals[5]/INTERVAL;                              // Average resource
  ExtraOutput[1] = StoredVals[6]/INTERVAL;                              // Average Cj
  ExtraOutput[2] = StoredVals[7]/INTERVAL;                              // Avergae Ca+Cb
  ExtraOutput[3] = StoredVals[8]/INTERVAL;                              // Average Cj+Ca+Cb
  ExtraOutput[4] = StoredVals[9]/INTERVAL;                              // Average P
  ExtraOutput[5] = StoredVals[10]/INTERVAL;                             // P.C. growth rate P

  return SUCCES;
}


/*====================================================================================================*/
```


## Specifying the parameter
```{r demo_CjaP}
parameters = c(0.1, 30.0, 1.0, 0.1, 0.5, 0.1, 0.015, 0.5, 3.0, 0.0, 0.0, 0.0, 0.0, 10.0, 0.0, 0.32, 0.032, 0.5, 0.005, 0.0, 3.0, 0.0, 1.0, 0.0);
```

### Juvenile biomass overcompensation detection in the consumer-resource equilibrium
```{r}
output1 <- FindCurve("CjaP", "EQ", c(0.0, 2.12019, 0.892170, 11.3152, 0.0), 0.5, c(0.0, 1.0), parameters, c("par1", "9", "par2", "13", "EXTfun", "1", "EXTpar", "9"), clean = TRUE, force = TRUE)

cat('', '> output1$bifpoints', sep='\n'); print(output1$bifpoints); cat('', '> output1$biftypes', sep='\n'); print(output1$biftypes)
```

#### The Plot
```{r}
par(mar = c(4, 5, 2, 5), tcl=0.4)
plot(1, 1, type="l", xaxs="i", yaxs="i", xlim=c(0.0, 0.3), ylim=c(0.0, 3.0), xlab="", ylab="")
mtext("Additional consumer mortality", 1, line=2.5, cex=1.3)
mtext("Average juvenile density", 2, line=3.5, cex=1.3)

lines(output1$curvepoints[,1], output1$curvepoints[,8], type="l", col=rgb(0,.6,0), lwd=3)
points(output1$bifpoints[,1], output1$bifpoints[,8], col="red", pch=8, lwd=2)
text(output1$bifpoints[,1], output1$bifpoints[,8], output1$biftype, pos=3, offset=0.35, adj = c(0.1))
```

### Juvenile biomass overcompensation boundary in the consumer-resource equilibrium as a function of consumer mortality and interval
```{r}
output2a <- FindCurve("CjaP", "EXT", output1$bifpoints[output1$biftypes == "EXT",1:6], 0.5, c(0.0, 1.0, 0.0, 70.0), parameters, c("par1", "9", "par2", "13", "EXTfun", "1", "EXTpar", "9"))

output2b <- FindCurve("CjaP", "EXT", output1$bifpoints[output1$biftypes == "EXT",1:6], -0.5, c(0.0, 1.0, 0.0, 70.0), parameters, c("par1", "9", "par2", "13", "EXTfun", "1", "EXTpar", "9"))

```

#### The Plot
```{r}
plot(1, 1, type="l", xaxs="i", yaxs="i", xlim=c(0.0, 0.3), ylim=c(0.0, 30.0), xlab="", ylab="")
mtext("Additional consumer mortality", 1, line=2.5, cex=1.3)
mtext("Interval", 2, line=3.5, cex=1.3)

lines(output2a$curvepoints[,1], output2a$curvepoints[,6], type="l", col=rgb(0,.6,0), lwd=3)
lines(output2b$curvepoints[,1], output2b$curvepoints[,6], type="l", col=rgb(0,.6,0), lwd=3)
```

### Predator extinction boundary as a function of consumer mortality and interval
```{r}
output3a <- FindCurve("CjaP", "BP", output1$bifpoints[output1$biftypes == "BP",1:6], 0.5, c(0.0, 1.0, 0.0, 70.0), parameters, c("par1", "9", "par2", "13"))

output3b <- FindCurve("CjaP", "BP", output1$bifpoints[output1$biftypes == "BP",1:6], -0.5, c(0.0, 1.0, 0.0, 70.0), parameters, c("par1", "9", "par2", "13"))

```

#### The Plot
```{r}
plot(1, 1, type="l", xaxs="i", yaxs="i", xlim=c(0.0, 0.3), ylim=c(0.0, 30.0), xlab="", ylab="")
mtext("Additional consumer mortality", 1, line=2.5, cex=1.3)
mtext("Interval", 2, line=3.5, cex=1.3)

lines(output2a$curvepoints[,1], output2a$curvepoints[,6], type="l", col=rgb(0,.6,0), lwd=3)
lines(output2b$curvepoints[,1], output2b$curvepoints[,6], type="l", col=rgb(0,.6,0), lwd=3)

lines(output3a$curvepoints[,1], output3a$curvepoints[,6], type="l", col=rgb(.6,0,0), lwd=3)
lines(output3b$curvepoints[,1], output3b$curvepoints[,6], type="l", col=rgb(.6,0,0), lwd=3)
```

## Set new parameter
```{r}

parameters = c(0.1, 30.0, 1.0, 0.1, 0.5, 0.1, 0.015, 1.5, 3.0, 0.0, 0.0, 0.0, 0.0, 70.0, 0.0, 0.32, 0.032, 0.5, 0.005, 0.0, 3.0, 0.0, 1.0, 0.0)
```

### Saddle-node bifurcation detection in the predator consumer-resource equilibrium
```{r}
output1 <- FindCurve("CjaP", "EQ", c(0.0, 27.0396, 0.590107, 0.132521, 1.84090), 0.2, c(0.0, 1.0), parameters, c("par1", "21", "par2", "13"))

cat('', '> output1$bifpoints', sep='\n'); print(output1$bifpoints); cat('', '> output1$biftypes', sep='\n'); print(output1$biftypes)
```

#### The Plot
```{r}
par(mar = c(4, 5, 2, 5), tcl=0.4)
plot(1, 1, type="l", xaxs="i", yaxs="i", xlim=c(0.0, 0.1), ylim=c(0.0, 5.0), xlab="", ylab="")
mtext("Additional predator mortality", 1, line=2.5, cex=1.3)
mtext("Average predator density", 2, line=3.5, cex=1.3)

lines(output1$curvepoints[,1], output1$curvepoints[,11], type="l", col=rgb(0,.6,0), lwd=3)
points(output1$bifpoints[,1], output1$bifpoints[,11], col="red", pch=8, lwd=2)
text(output1$bifpoints[,1], output1$bifpoints[,11], output1$biftype, pos=3, offset=0.35, adj = c(0.1))
```

### Saddle-node bifurcation as a function of predator mortality and interval
```{r}
output2 <- FindCurve("CjaP", "LP", output1$bifpoints[1,1:6], -0.2, c(0.0, 1.0, 0.0, 70.0), parameters, c("par1", "21", "par2", "13"))

output3 <- FindCurve("CjaP", "LP", output1$bifpoints[2,1:6], -0.2, c(0.0, 1.0, 0.0, 70.0), parameters, c("par1", "21", "par2", "13"))
```

#### The Plot
```{r}
plot(1, 1, type="l", xaxs="i", yaxs="i", xlim=c(0.0, 0.1), ylim=c(0.0, 70.0), xlab="", ylab="")
mtext("Additional predator mortality", 1, line=2.5, cex=1.3)
mtext("Interval", 2, line=3.5, cex=1.3)

lines(output2$curvepoints[,1], output2$curvepoints[,6], type="l", col=rgb(.6,0,0), lwd=3)
lines(output3$curvepoints[,1], output3$curvepoints[,6], type="l", col=rgb(.6,0,0), lwd=3)
```

### Predator invasion boundary as a function of predator mortality and interval
```{r}
output4 <- FindCurve("CjaP", "BP", output1$bifpoints[3,1:6], -0.2, c(0.0, 1.0, 0.0, 70.0), parameters, c("par1", "21", "par2", "13"))
```

#### The Plot
```{r}
plot(1, 1, type="l", xaxs="i", yaxs="i", xlim=c(0.0, 0.1), ylim=c(0.0, 70.0), xlab="", ylab="")
mtext("Additional predator mortality", 1, line=2.5, cex=1.3)
mtext("Interval", 2, line=3.5, cex=1.3)

lines(output2$curvepoints[,1], output2$curvepoints[,6], type="l", col=rgb(.6,0,0), lwd=3)
lines(output3$curvepoints[,1], output3$curvepoints[,6], type="l", col=rgb(.6,0,0), lwd=3)
lines(output4$curvepoints[,1], output4$curvepoints[,6], type="l", col=rgb(0,0,0.6), lwd=3)
```
## Clean everything up
```{r}
CleanFindCurve('F')
```

# Demo C2rja

## The Model
```{c, eval = FALSE}
/*
  NAME
    C2rja
  PURPOSE
    Module computes the internal equilibrium of the stage-structured biomass model
    with two resources, a possible niche shift at maturation and pulsed reproduction

  Last modification: AMdR - Jan 26, 2018
 */

/*
 *=================================================================================================================
 *  DEFINITION OF PROBLEM DIMENSIONS AND NUMERICAL SETTINGS
 *=================================================================================================================
 */
// Dimension settings: Required
#define EQUATIONS_DIM             4
#define EXTRAOUTPUT_DIM           6
#define PARAMETER_NR              14

// Numerical settings: Optional (default values adopted otherwise)
#define DYTOL                     1.0E-8                                  // Variable tolerance
#define RHSTOL                    1.0E-9                                  // Function tolerance
#define ALLOWNEGATIVE             0                                       // Negative solution components allowed?


/*
 *=================================================================================================================
 *  DEFINITION OF ALIASES
 *=================================================================================================================
 */
// Define aliases for the parameters
#define DELTA                     parameter[0]
#define R1MAX                     parameter[1]
#define R2MAX                     parameter[2]

// Parameters for consumer
#define SIGMA                     parameter[3]

#define ZC                        parameter[4]

#define IMAX                      parameter[5]
#define Q                         parameter[6]
#define E                         parameter[7]
#define MUC                       parameter[8]

#define ETA                       parameter[9]

#define MUCPLUS                   parameter[10]
#define MUCJPLUS                  parameter[11]
#define MUCAPLUS                  parameter[12]

// Parameters for consumer related to discrete reproduction
#define INTERVAL                  parameter[13]

/*
 *=================================================================================================================
 *  DEFINITION OF NAMES AND DEFAULT VALUES OF THE PARAMETERS
 *=================================================================================================================
 */
// At least two parameters should be specified in this array
char *parameternames[PARAMETER_NR] = {"Delta", "Rmax1", "Rmax2", "Sigma",   "Zc",       "Imax",     "Q",
                                      "E",     "Muc",   "Eta",   "MucPlus", "MucjPlus", "MucaPlus", "Interval"};

// These are the default parameters values
double parameter[PARAMETER_NR] = {10.0, 2.0, 2.0, 0.5, 0.1, 100.0, 10.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0};

/*
 *=================================================================================================================
 *  DEFINITION OF THE SYSTEM OF EQUATIONS TO SOLVE
 *=================================================================================================================
 */

#undef MAX_EXP
#define MAX_EXP                   50.0

double Maturation(double z, double nuj, double muj)

{
  double logz, tmp, tres, matrate = 0.0;

  logz = log(z);
  tres = muj/(1.0 - MAX_EXP/logz);
  if (nuj < tres)
    matrate = 0.0;
  else
    {
      tmp = 1.0 - muj/nuj;
      if (fabs(tmp) < 1.0E-6)
        matrate = tmp/2 - 1/logz;
      else
        matrate = tmp/(1.0 - exp(tmp*logz));
    }
  matrate *= nuj;

  return matrate;
}


/*=================================================================================================================*/

// The ODE system defining the change in state variables during the growth period

#define ODEDIM                    11
static double                     StoredVals[ODEDIM];
static int                        OdeDim = ODEDIM;

#define R1                        argument[0]                             // Resource #1
#define R2                        argument[1]                             // Resource #2
#define CJ                        argument[2]                             // Juvenile consumers
#define CA                        argument[3]                             // Adult consumers
#define B                         argument[4]                             // energy storage

#define DR1DT                     derivative[0]                           // Resource #1
#define DR2DT                     derivative[1]                           // Resource #2
#define DCJDT                     derivative[2]                           // Juvenile consumers
#define DCADT                     derivative[3]                           // Adult consumers
#define DBDT                      derivative[4]                           // Energy storage

void WithinSeason(double t, double *argument, double *derivative)
{
  static double ingest_R1, ingest_R2;
  static double nu_J, nu_A;
  static double mort_J, mort_A, maturation;

  nu_J = SIGMA*IMAX*R1 - Q;
  nu_A = SIGMA*IMAX*((ETA*R1 + (1.0 - ETA)*R2)) - Q*(1 + E*B/CA);

  ingest_R1 = IMAX*(R1*CJ + ETA*R1*CA);
  ingest_R2 = IMAX*(1.0 - ETA)*R2*CA;

  mort_J = MUC + MUCJPLUS + MUCPLUS;                                      // Starvation mortality (max(nu_J, 0.0)-nu_J)
                                                                          // not included here !
  mort_A = MUC + MUCAPLUS + MUCPLUS + max(nu_A, 0.0) - nu_A;

  maturation = Maturation(ZC, nu_J, mort_J)*CJ;

  DR1DT = DELTA*(R1MAX - R1) - ingest_R1;
  DR2DT = DELTA*(R2MAX - R2) - ingest_R2;

  DCJDT = nu_J*CJ - maturation - mort_J*CJ;
  DCADT = maturation - mort_A*CA;
  DBDT  = max(nu_A, 0.0)*CA - mort_A*B;

  // Integrate the following ODEs only for output purposes
  if (OdeDim == ODEDIM)
    {
      derivative[5]  = R1;
      derivative[6]  = R2;
      derivative[7]  = CJ;
      derivative[8]  = CA;
      derivative[9]  = CA + B;
      derivative[10] = CJ + CA + B;
    }

  return;
}


/*=================================================================================================================*/
// Routine specifying the system of equalities from which to solve for
// R, J and A at equilibrium
#define PERIOD 1

int Equations(double *argument, double *result)

{
  int     period;
  double  tval, tend, x[ODEDIM];

  //================================================================================
  // Set the initial point for the ODEs

  memset(x, 0, ODEDIM*sizeof(double));
  x[0] = R1;
  x[1] = R2;
  x[2] = CJ;
  x[3] = CA;

  if (result)
    OdeDim = 5;
  else
    OdeDim = ODEDIM;
  tval     = 0.0;
  tend     = INTERVAL;

  for (period = 0; period < PERIOD; period++)
    {
      tend = (period + 1)*INTERVAL;
      // Integrate up to end of the growing phase
      if (odesolve(x, OdeDim, &tval, tend, WithinSeason, NULL) == FAILURE)
        {
          ErrorMsg(__FILE__, __LINE__, "Integration failed!");
          return FAILURE;
        }
      if (!result) memcpy(StoredVals, x, ODEDIM*sizeof(double));
      x[2] += x[4];                                                       // Add reproductive mass to juveniles
      x[4] = 0.0;                                                         // Reset reproductive mass
    }

  //================================================================================
  // Compute the final values of the fixed point equation F(y)=0,

  if (result)
    {
      result[0] = (R1 - x[0]);
      result[1] = (R2 - x[1]);
      result[2] = (CJ - x[2]);
      result[3] = (CA - x[3]);
    }

  return SUCCES;
}


/*=================================================================================================================*/

// Define all variables to be written to the output file (column-organized ASCII file)

int DefineExtraOutput(double *argument, double *ExtraOutput)

{
  // Invoke the routine that sets the right-hand side for setting the output variables
  if (Equations(argument, NULL) == FAILURE) return FAILURE;

  ExtraOutput[0] = StoredVals[5]/INTERVAL;                                // Average resource 1
  ExtraOutput[1] = StoredVals[6]/INTERVAL;                                // Average resource 2
  ExtraOutput[2] = StoredVals[7]/INTERVAL;                                // Avergae Cj
  ExtraOutput[3] = StoredVals[8]/INTERVAL;                                // Average Ca
  ExtraOutput[4] = StoredVals[9]/INTERVAL;                                // Average Ca+Cb
  ExtraOutput[5] = StoredVals[10]/INTERVAL;                               // Average Cj+Ca+Cb

  return SUCCES;
}


/*=================================================================================================================*/
```


## Specifying the parameter
```{r}
init = c(2.07278E-01, 2.07266E-01, 2.00000E+00, 1.00656E-05, 8.00686E-08);
parameters = c(1.0, 2.0, 2.0, 0.5, 0.1, 10.0, 1.0, 0.0, 0.1, 0.0, 0.0, 0.0, 0.0, 10.0);
```

### Consumer-resource equilibrium as a function of R1max for default parameters
```{r}
output1 <- FindCurve("C2rja", "EQ", init, 0.1, c(0.0, 3.0), parameters, options = c("par1", "1"), clean = TRUE, force = TRUE)

cat('', '> output1$bifpoints', sep='\n'); print(output1$bifpoints); cat('', '> output1$biftypes', sep='\n'); print(output1$biftypes)

```
### The Plot
```{r}
par(mar = c(4, 5, 2, 5), tcl=0.4)
plot(1, 1, type="l", xaxs="i", yaxs="i", xlim=c(0.0, 3.0), ylim=c(0.0, 1.2), xlab="", ylab="")
mtext("Maximum density resource 1", 1, line=2.5, cex=1.3)
mtext("Average consumer density", 2, line=3.5, cex=1.3)

lines(output1$curvepoints[,1], output1$curvepoints[,9], type="l", col=rgb(0.6,0,0), lwd=3)
points(output1$bifpoints[,1], output1$bifpoints[,9], col="red", pch=8, lwd=2)
text(output1$bifpoints[,1], output1$bifpoints[,9], output1$biftype, pos=3, offset=0.35, adj = c(0.1))

lines(output1$curvepoints[,1], output1$curvepoints[,10], type="l", col=rgb(0,0,0.6), lwd=3)
points(output1$bifpoints[,1], output1$bifpoints[,10], col="red", pch=8, lwd=2)
text(output1$bifpoints[,1], output1$bifpoints[,10], output1$biftype, pos=3, offset=0.35, adj = c(0.1))

CleanFindCurve('F')
```
